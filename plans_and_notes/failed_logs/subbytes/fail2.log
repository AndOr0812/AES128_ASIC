ndom -c -wlf run1.wlf -do "log -r /*; run -all" subbytes_test_top
Reading pref.tcl 

# 10.2c

# vsim -do {log -r /*; run -all} -c -sv_seed random -wlf run1.wlf -sv_lib aes subbytes_test_top 
# ** Note: (vsim-3813) Design is being optimized due to module recompilation...
# ** Warning: subbytes_tb.sv(104): (vopt-LRM-2897) Using non-standard foreach loop variable list syntax.
# ** Warning: subbytes_tb.sv(76): (vopt-2240) Treating stand-alone use of function 'randomize' as an implicit VOID cast.
# //  Questa Sim-64
# //  Version 10.2c linux_x86_64 Jul 18 2013
# //
# //  Copyright 1991-2013 Mentor Graphics Corporation
# //  All Rights Reserved.
# //
# //  THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION
# //  WHICH IS THE PROPERTY OF MENTOR GRAPHICS CORPORATION OR ITS
# //  LICENSORS AND IS SUBJECT TO LICENSE TERMS.
# //
# Loading sv_std.std
# Loading work.subbytes_test_top(fast)
# Loading work.subbytes_test(fast)
# ** Warning: (vsim-PLI-3691) subbytes_test_top.sv(29): Expected a system task, not a system function '$value$plusargs'.
#         Region: /subbytes_test_top
# Loading ./aes.so
# Sv_Seed = 3879820752
# log -r /* 
#  run -all 
#                    0[ns]: reset - 0x1
#                   30[ns]: reset - 0x0, should have reset triggered
#                   50[ns]: The reg values are:
# 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
# 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
# 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
# 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
# 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
# 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
# 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
# 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
# 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
# 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
# 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
# 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
# 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
# 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
# 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
# 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
#                  150[ns]: sbox_data = 0x16bb54b00f2d99416842e6bf0d89a18cdf2855cee9871e9b948ed9691198f8e19e1dc186b95735610ef6034866b53e708a8bbd4b1f74dde8c6b4a61c2e2578ba08ae7a65eaf4566ca94ed58d6d37c8e779e4959162acd3c25c2406490a3a32e0db0b5ede14b8ee4688902a22dc4f816073195d643d7ea7c41744975fec130ccdd2f3ff1021dab6bcf5389d928f40a351a89f3c507f02f94585334d43fbaaefd0cf584c4a39becb6a5bb1fc20ed00d153842fe329b3d63b52a05a6e1b1a2c830975b227ebe28012079a059618c323c7041531d871f1e5a534ccf73f362693fdb7c072a49cafa2d4adf04759fa7dc982ca76abd7fe2b670130c56f6bf27b777c63, writing to the sbox lut tables
#                  250[ns]: The reg values are:
# 0x16 0xbb 0x54 0xb0 0x0f 0x2d 0x99 0x41 0x68 0x42 0xe6 0xbf 0x0d 0x89 0xa1 0x8c 
# 0xdf 0x28 0x55 0xce 0xe9 0x87 0x1e 0x9b 0x94 0x8e 0xd9 0x69 0x11 0x98 0xf8 0xe1 
# 0x9e 0x1d 0xc1 0x86 0xb9 0x57 0x35 0x61 0x0e 0xf6 0x03 0x48 0x66 0xb5 0x3e 0x70 
# 0x8a 0x8b 0xbd 0x4b 0x1f 0x74 0xdd 0xe8 0xc6 0xb4 0xa6 0x1c 0x2e 0x25 0x78 0xba 
# 0x08 0xae 0x7a 0x65 0xea 0xf4 0x56 0x6c 0xa9 0x4e 0xd5 0x8d 0x6d 0x37 0xc8 0xe7 
# 0x79 0xe4 0x95 0x91 0x62 0xac 0xd3 0xc2 0x5c 0x24 0x06 0x49 0x0a 0x3a 0x32 0xe0 
# 0xdb 0x0b 0x5e 0xde 0x14 0xb8 0xee 0x46 0x88 0x90 0x2a 0x22 0xdc 0x4f 0x81 0x60 
# 0x73 0x19 0x5d 0x64 0x3d 0x7e 0xa7 0xc4 0x17 0x44 0x97 0x5f 0xec 0x13 0x0c 0xcd 
# 0xd2 0xf3 0xff 0x10 0x21 0xda 0xb6 0xbc 0xf5 0x38 0x9d 0x92 0x8f 0x40 0xa3 0x51 
# 0xa8 0x9f 0x3c 0x50 0x7f 0x02 0xf9 0x45 0x85 0x33 0x4d 0x43 0xfb 0xaa 0xef 0xd0 
# 0xcf 0x58 0x4c 0x4a 0x39 0xbe 0xcb 0x6a 0x5b 0xb1 0xfc 0x20 0xed 0x00 0xd1 0x53 
# 0x84 0x2f 0xe3 0x29 0xb3 0xd6 0x3b 0x52 0xa0 0x5a 0x6e 0x1b 0x1a 0x2c 0x83 0x09 
# 0x75 0xb2 0x27 0xeb 0xe2 0x80 0x12 0x07 0x9a 0x05 0x96 0x18 0xc3 0x23 0xc7 0x04 
# 0x15 0x31 0xd8 0x71 0xf1 0xe5 0xa5 0x34 0xcc 0xf7 0x3f 0x36 0x26 0x93 0xfd 0xb7 
# 0xc0 0x72 0xa4 0x9c 0xaf 0xa2 0xd4 0xad 0xf0 0x47 0x59 0xfa 0x7d 0xc9 0x82 0xca 
# 0x76 0xab 0xd7 0xfe 0x2b 0x67 0x01 0x30 0xc5 0x6f 0x6b 0xf2 0x7b 0x77 0x7c 0x63 
#                  350[ns]: generated_data = 0xb55e391c
#                  350[ns]: C model output = 0xd558129c
#                  450[ns]: [ERROR] The C model output value 0xd558129c and output DUT value do not match 0xaf6b7d7c, data_out_vld = 1b'1, key_expansson access is 1b'0
# ** Note: $finish    : subbytes_tb.sv(142)
#    Time: 450 ns  Iteration: 1  Instance: /subbytes_test_top/subbytes_test

// - changed 			case (block_byte_data[3:0]) to 			case (block_byte_data[7:4])  - as it the first number should be x not y coordinate in get_sbox_data;

########################################################################################
// Then it still did not match - added debug statements in the function - 

	function [7:0] get_sbox_data;
		//byte_data[7:4] - is the x coordidate, byte_data[3:0] is the y coordinate for the sbox matrix.
		input [7:0] block_byte_data;
		begin
			
			//firstly get the array of data for y coordinate, then launch a different function to get the x coordindate data
			case (block_byte_data[7:4])
				4'h0 : $display("0 is trig"); //get_sbox_data = get_y_from_sbox( 0,block_byte_data[3:0]);
				4'h1 : $display("1 is trig"); //get_sbox_data = get_y_from_sbox( 1,block_byte_data[3:0]);
				4'h2 : $display("2 is trig"); //get_sbox_data = get_y_from_sbox( 2,block_byte_data[3:0]);
				4'h3 : $display("3 is trig"); //get_sbox_data = get_y_from_sbox( 3,block_byte_data[3:0]);
				4'h4 : $display("4 is trig"); //get_sbox_data = get_y_from_sbox( 4,block_byte_data[3:0]);
				4'h5 : $display("5 is trig"); //get_sbox_data = get_y_from_sbox( 5,block_byte_data[3:0]);
				4'h6 : $display("6 is trig"); //get_sbox_data = get_y_from_sbox( 6,block_byte_data[3:0]);
				4'h7 : $display("7 is trig"); //get_sbox_data = get_y_from_sbox( 7,block_byte_data[3:0]);
				4'h8 : $display("8 is trig"); //get_sbox_data = get_y_from_sbox( 8,block_byte_data[3:0]);
				4'h9 : $display("9 is trig"); //get_sbox_data = get_y_from_sbox( 9,block_byte_data[3:0]);
				4'ha : $display("a is trig"); //get_sbox_data = get_y_from_sbox(10,block_byte_data[3:0]);
				4'hb : $display("b is trig"); //get_sbox_data = get_y_from_sbox(11,block_byte_data[3:0]);
				4'hc : $display("c is trig"); //get_sbox_data = get_y_from_sbox(12,block_byte_data[3:0]);
				4'hd : $display("d is trig"); //get_sbox_data = get_y_from_sbox(13,block_byte_data[3:0]);
				4'he : $display("e is trig"); //get_sbox_data = get_y_from_sbox(14,block_byte_data[3:0]);
				4'hf : $display("f is trig"); //get_sbox_data = get_y_from_sbox(15,block_byte_data[3:0]);
			endcase
		end
		$display("get_sbox_data input is 0x%x, input to get_y_from_sbox is 0x%x, output is 0x%x", block_byte_data[7:4], block_byte_data[3:0], get_sbox_data);
	endfunction
	
	Output - 
	# e is trig
# get_sbox_data input is 0xe, input to get_y_from_sbox is 0x8, output is 0xxx
# 8 is trig
# get_sbox_data input is 0x8, input to get_y_from_sbox is 0xc, output is 0xxx
# a is trig
# get_sbox_data input is 0xa, input to get_y_from_sbox is 0x4, output is 0xxx
# a is trig
# get_sbox_data input is 0xa, input to get_y_from_sbox is 0x2, output is 0xxx

- hence top function appeared to be working properly, hence test on the bottom function was done, with testing the passed index - output was as shown below, which means that the case statement was working properly, but index was not - which indicated that most likely it is not percieved as an integer, but as bit.
	###############################################################################################
	# 8 is trig
# get_y_from_sbox input 0x8, index is 0
# c is trig
# get_y_from_sbox input 0xc, index is 0
# 4 is trig
# get_y_from_sbox input 0x4, index is 0
# 2 is trig
# get_y_from_sbox input 0x2, index is 0
	##############################################################
	Then it was chagned from 		input index; to	input integer index; and function appeared to be working correctly.

	
