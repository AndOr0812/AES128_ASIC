.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parser 3pm"
.TH Parser 3pm "2015-03-14" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Verilog::Parser \- Parse Verilog language files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Verilog::Parser;
\&
\&  my $parser = new Verilog::Parser;
\&  $string = $parser\->unreadback ();
\&  $line   = $parser\->lineno ();
\&  $parser\->parse ($text)
\&  $parser\->parse_file ($filename)
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Verilog::Parser will tokenize a Verilog file when the \fIparse()\fR method is
called and invoke various callback methods.  This is useful for extracting
information and editing files while retaining all context.  For netlist
like extractions, see Verilog::Netlist.
.PP
See the \*(L"Which Package\*(R" section of Verilog::Language if you are unsure
which parsing package to use for a new application.
.PP
Note the parser allows some constructs that are syntax errors according to
the specification (for example \*(L"\fIfoo.bar\fR\|(1)++\*(R".) This is done when the
parser can't easily detect these cases.  It's up to the consumer of the
parser to filter out such errors if it cares.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$parser = Verilog::Parser\->new (args...)" 4
.el .IP "\f(CW$parser\fR = Verilog::Parser\->new (args...)" 4
.IX Item "$parser = Verilog::Parser->new (args...)"
Create a new Parser.
.Sp
Adding \*(L"symbol_table => []\*(R" will use the specified symbol table for this
parse, and modify the array reference to include those symbols detected by
this parse.  As the SystemVerilog language requires packages and typedefs
to exist before they are referenced, you must pass the same symbol_table to
subsequent parses that are for the same compilation scope.  The internals
of this symbol_table should be considered opaque, as it will change between
package versions, and must not be modified by user code.
.Sp
Adding \*(L"use_cb_{callback\-name} => 0\*(R" will disable the specified callback.
By default, all callbacks will be called; disabling callbacks can greatly
speed up the parser as a large percentage of time is spent calling between
C and Perl to invoke the callbacks.  When using this feature,
use_unreadback=>0 should be used too, as since whole tokens are skipped,
skipping whitespace shouldn't matter either.
.Sp
Adding \*(L"use_std => 1\*(R" will add parsing of the SystemVerilog built-in std::
package, or \*(L"use_std => 0\*(R" will disable it.  If unspecified it is silently
included (no callbacks will be involed) when suspected to be necessary.
.Sp
Adding \*(L"use_unreadback => 0\*(R" will disable later use of the unreadback
method, which may improve performance.
.Sp
Adding \*(L"use_vars => 0\*(R" will disable contassign, defparam, pin, var and port
callbacks to Verilog::SigParser.  This can greatly speed parsing when
variable and interconnect information is not required.
.ie n .IP "$parser\->callback_names ()" 4
.el .IP "\f(CW$parser\fR\->callback_names ()" 4
.IX Item "$parser->callback_names ()"
Return an array of callback function names.  This may be used to
automatically create callbacks for all functions, or to test for different
callback functionality between versions of Verilog-Perl.
.ie n .IP "$parser\->eof ()" 4
.el .IP "\f(CW$parser\fR\->eof ()" 4
.IX Item "$parser->eof ()"
Indicate the end of the input stream.  All incomplete tokens will be parsed
and all remaining callbacks completed.
.ie n .IP "$parser\->filename ($set)" 4
.el .IP "\f(CW$parser\fR\->filename ($set)" 4
.IX Item "$parser->filename ($set)"
Return (if \f(CW$set\fR is undefined) or set current filename.
.ie n .IP "$parser\->lineno ($set)" 4
.el .IP "\f(CW$parser\fR\->lineno ($set)" 4
.IX Item "$parser->lineno ($set)"
Return (if \f(CW$set\fR is undefined) or set current line number.
.ie n .IP "$parser\->parse ($string)" 4
.el .IP "\f(CW$parser\fR\->parse ($string)" 4
.IX Item "$parser->parse ($string)"
Parse the \f(CW$string\fR as verilog text.  Can be called multiple times.  Note not
all callbacks may be invoked until the eof method is called.
.ie n .IP "$parser\->parse_file ($filename);" 4
.el .IP "\f(CW$parser\fR\->parse_file ($filename);" 4
.IX Item "$parser->parse_file ($filename);"
This method can be called to parse text from a file.  The argument can
be a filename or an already opened file handle. The return value from
\&\fIparse_file()\fR is a reference to the parser object.
.ie n .IP "$parser\->parse_preproc_file ($preproc);" 4
.el .IP "\f(CW$parser\fR\->parse_preproc_file ($preproc);" 4
.IX Item "$parser->parse_preproc_file ($preproc);"
This method can be called to parse preprocessed text from a predeclared
Verilog::Preproc object.
.ie n .IP "$parser\->unreadback ($string)" 4
.el .IP "\f(CW$parser\fR\->unreadback ($string)" 4
.IX Item "$parser->unreadback ($string)"
Return any input string from the file that has not been sent to the
callback.  This will include whitespace and tokens which did not have a
callback.  (For example comments, if there is no comment callback.)  This
is useful for recording the entire contents of the input, for
preprocessors, pretty-printers, and such.
.Sp
With the optional argument, set the text to be returned with the next
unreadback call.  See also unreadbackCat, which is much faster.
.Sp
To use this option, \*(L"use_unreadback => 1\*(R" must have been passed to the
constructor.
.ie n .IP "$parser\->unreadbackCat ($text)" 4
.el .IP "\f(CW$parser\fR\->unreadbackCat ($text)" 4
.IX Item "$parser->unreadbackCat ($text)"
Add text to be returned with the next unreadback call.  This is much faster
than using \*(L"$parser\->unreadback($parser\->unreadback . \f(CW$text\fR)\*(R".
.SH "CALLBACKS"
.IX Header "CALLBACKS"
In order to make the parser do anything interesting, you must make a
subclass where you override one or more of the following callback methods
as appropriate.
.ie n .IP "$self\->attribute ( $token )" 4
.el .IP "\f(CW$self\fR\->attribute ( \f(CW$token\fR )" 4
.IX Item "$self->attribute ( $token )"
This method is called when any text in (* *) are recognized.  The first
argument, \f(CW$token\fR, is the contents of the attribute including the delimiters.
.ie n .IP "$self\->comment ( $token )" 4
.el .IP "\f(CW$self\fR\->comment ( \f(CW$token\fR )" 4
.IX Item "$self->comment ( $token )"
This method is called when any text in // or /**/ comments are recognized.
The first argument, \f(CW$token\fR, is the contents of the comment including the
comment delimiters.
.ie n .IP "$self\->endparse ( $token )" 4
.el .IP "\f(CW$self\fR\->endparse ( \f(CW$token\fR )" 4
.IX Item "$self->endparse ( $token )"
This method is called when the file has been completely parsed, at the
End-Of-File of the parsed file.  It is useful for writing clean up
routines.
.ie n .IP "$self\->keyword ( $token )" 4
.el .IP "\f(CW$self\fR\->keyword ( \f(CW$token\fR )" 4
.IX Item "$self->keyword ( $token )"
This method is called when any Verilog keyword is recognized.
The first argument, \f(CW$token\fR, is the keyword.
.ie n .IP "$self\->number ( $token )" 4
.el .IP "\f(CW$self\fR\->number ( \f(CW$token\fR )" 4
.IX Item "$self->number ( $token )"
This method is called when any number is recognized.  The first argument,
\&\f(CW$token\fR, is the number.  The Verilog::Language::number_value function may be
useful for converting a Verilog value to a Perl integer.
.ie n .IP "$self\->operator ( $token )" 4
.el .IP "\f(CW$self\fR\->operator ( \f(CW$token\fR )" 4
.IX Item "$self->operator ( $token )"
This method is called when any symbolic operator (+, \-, etc) is recognized.
The first argument, \f(CW$token\fR, is the operator.
.ie n .IP "$self\->preproc ( $token )" 4
.el .IP "\f(CW$self\fR\->preproc ( \f(CW$token\fR )" 4
.IX Item "$self->preproc ( $token )"
This method is called when any Verilog preprocessor `command is recognized.
Most of these are handled by the preprocessor, however any unrecognized
`defines are passed through.  For backward compatibility, if not defined
this function will call the symbol callback.
.ie n .IP "$self\->string ( $token )" 4
.el .IP "\f(CW$self\fR\->string ( \f(CW$token\fR )" 4
.IX Item "$self->string ( $token )"
This method is called when any text in double quotes are recognized, or on
the text of protected regions.  The first argument, \f(CW$token\fR, is the contents
of the string including the quotes.
.ie n .IP "$self\->symbol ( $token )" 4
.el .IP "\f(CW$self\fR\->symbol ( \f(CW$token\fR )" 4
.IX Item "$self->symbol ( $token )"
This method is called when any Verilog symbol is recognized.  A symbol is
considered a non-keyword bare-word.  The first argument, \f(CW$token\fR, is the
symbol.
.ie n .IP "$self\->sysfunc ( $token )" 4
.el .IP "\f(CW$self\fR\->sysfunc ( \f(CW$token\fR )" 4
.IX Item "$self->sysfunc ( $token )"
This method is called when any Verilog \f(CW$syscall\fR is recognized.  The first
argument, \f(CW$token\fR, is the symbol.  For backward compatibility, if not
defined this function will call the symbol callback.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
Here's a simple example which will print every symbol in a verilog
file.
.PP
.Vb 3
\&  package MyParser;
\&  use Verilog::Parser;
\&  @ISA = qw(Verilog::Parser);
\&
\&  # parse, parse_file, etc are inherited from Verilog::Parser
\&  sub new {
\&      my $class = shift;
\&      #print "Class $class\en";
\&      my $self = $class\->SUPER::new();
\&      bless $self, $class;
\&      return $self;
\&  }
\&
\&  sub symbol {
\&      my $self = shift;
\&      my $token = shift;
\&
\&      $self\->{symbols}{$token}++;
\&  }
\&
\&  sub report {
\&      my $self = shift;
\&
\&      foreach my $sym (sort keys %{$self\->{symbols}}) {
\&         printf "Symbol %\-30s occurs %4d times\en",
\&         $sym, $self\->{symbols}{$sym};
\&      }
\&  }
\&
\&  package main;
\&
\&  my $parser = MyParser\->new();
\&  $parser\->parse_file (shift);
\&  $parser\->report();
.Ve
.SH "BUGS"
.IX Header "BUGS"
This is being distributed as a baseline for future contributions.  Don't
expect a lot, the Parser is still naive, and there are many awkward cases
that aren't covered.
.PP
The parser currently assumes the string it is passed ends on a newline
boundary.  It should be changed to allow arbitrary chunks.
.PP
Cell instantiations without any arguments are not supported, an empty set
of parenthesis are required.  (Use \*(L"cell \fIcell()\fR;\*(R", not \*(L"cell cell;\*(R".)
.SH "DISTRIBUTION"
.IX Header "DISTRIBUTION"
Verilog-Perl is part of the <http://www.veripool.org/> free Verilog \s-1EDA\s0
software tool suite.  The latest version is available from \s-1CPAN\s0 and from
<http://www.veripool.org/verilog\-perl>.
.PP
Copyright 2000\-2015 by Wilson Snyder.  This package is free software; you
can redistribute it and/or modify it under the terms of either the \s-1GNU\s0
Lesser General Public License Version 3 or the Perl Artistic License Version 2.0.
.SH "AUTHORS"
.IX Header "AUTHORS"
Wilson Snyder <wsnyder@wsnyder.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Verilog-Perl,
Verilog::Preproc,
Verilog::SigParser,
Verilog::Language,
Verilog::Netlist,
Verilog::Getopt,
vrename,
vpassert
vppreproc
