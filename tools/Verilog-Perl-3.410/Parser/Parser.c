/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.18 from the
 * contents of Parser.xs. Do not edit this file, edit Parser.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Parser.xs"
#/* Verilog.xs -- Verilog Booter  -*- C++ -*-
#*********************************************************************
#*
#* DESCRIPTION: Verilog::Parser Perl XS interface
#*
#* Author: Wilson Snyder <wsnyder@wsnyder.org>
#*
#* Code available from: http://www.veripool.org/
#*
#*********************************************************************
#*
#* Copyright 2000-2015 by Wilson Snyder.  This program is free software;
#* you can redistribute it and/or modify it under the terms of either the GNU
#* Lesser General Public License Version 3 or the Perl Artistic License Version 2.0.
#*
#* This program is distributed in the hope that it will be useful,
#* but WITHOUT ANY WARRANTY; without even the implied warranty of
#* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#* GNU General Public License for more details.
#*
#* You should have received a copy of the Perl Artistic License
#* along with this module; see the file COPYING.  If not, see
#* www.cpan.org
#*
#***********************************************************************
#* Note with C++ XS libraries, the CLASS parameter is implied...
#***********************************************************************/

/* Mine: */
#include "VParse.h"
#include "VSymTable.h"
#include "VAst.h"
#include <cstring>
#include <deque>

/* Perl */
extern "C" {
# include "EXTERN.h"
# include "perl.h"
# include "XSUB.h"
}

#ifdef open
# undef open	/* Perl 64 bit on solaris has a nasty hack that redefines open */
#endif

class VFileLineParseXs;

#//**********************************************************************
#// Parseressor derived classes, so we can override the callbacks to call perl.

class VParserXs : public VParse {
public:
    SV*		m_self;	// Class called from (the hash, not SV pointing to the hash)
    VFileLine*	m_cbFilelinep;	///< Last callback's starting point
    deque<VFileLineParseXs*> m_filelineps;

    // CALLBACKGEN_H_MEMBERS
    // CALLBACKGEN_GENERATED_BEGIN - GENERATED AUTOMATICALLY by callbackgen
    struct {  // Bit packed to help the cache
        bool m_useCb_attribute:1;
        bool m_useCb_class:1;
        bool m_useCb_comment:1;
        bool m_useCb_contassign:1;
        bool m_useCb_covergroup:1;
        bool m_useCb_defparam:1;
        bool m_useCb_endcell:1;
        bool m_useCb_endclass:1;
        bool m_useCb_endgroup:1;
        bool m_useCb_endinterface:1;
        bool m_useCb_endmodport:1;
        bool m_useCb_endmodule:1;
        bool m_useCb_endpackage:1;
        bool m_useCb_endparse:1;
        bool m_useCb_endprogram:1;
        bool m_useCb_endtaskfunc:1;
        bool m_useCb_function:1;
        bool m_useCb_import:1;
        bool m_useCb_instant:1;
        bool m_useCb_interface:1;
        bool m_useCb_keyword:1;
        bool m_useCb_modport:1;
        bool m_useCb_module:1;
        bool m_useCb_number:1;
        bool m_useCb_operator:1;
        bool m_useCb_package:1;
        bool m_useCb_parampin:1;
        bool m_useCb_pin:1;
        bool m_useCb_port:1;
        bool m_useCb_preproc:1;
        bool m_useCb_program:1;
        bool m_useCb_string:1;
        bool m_useCb_symbol:1;
        bool m_useCb_sysfunc:1;
        bool m_useCb_task:1;
        bool m_useCb_var:1;
    };
    // CALLBACKGEN_GENERATED_END - GENERATED AUTOMATICALLY by callbackgen

    VFileLine* cbFilelinep() const { return m_cbFilelinep; }
    void cbFileline(VFileLine* filelinep) { m_cbFilelinep = filelinep; }

    VParserXs(VFileLine* filelinep, av* symsp, bool sigparser, bool useUnreadback)
	: VParse(filelinep, symsp, sigparser, useUnreadback)
	, m_cbFilelinep(filelinep)
	{ set_cb_use(); }
    virtual ~VParserXs();

    // CALLBACKGEN_CB_USE
    // CALLBACKGEN_GENERATED_BEGIN - GENERATED AUTOMATICALLY by callbackgen
    void set_cb_use() {
       m_useCb_attribute = true;
       m_useCb_class = true;
       m_useCb_comment = true;
       m_useCb_contassign = true;
       m_useCb_covergroup = true;
       m_useCb_defparam = true;
       m_useCb_endcell = true;
       m_useCb_endclass = true;
       m_useCb_endgroup = true;
       m_useCb_endinterface = true;
       m_useCb_endmodport = true;
       m_useCb_endmodule = true;
       m_useCb_endpackage = true;
       m_useCb_endparse = true;
       m_useCb_endprogram = true;
       m_useCb_endtaskfunc = true;
       m_useCb_function = true;
       m_useCb_import = true;
       m_useCb_instant = true;
       m_useCb_interface = true;
       m_useCb_keyword = true;
       m_useCb_modport = true;
       m_useCb_module = true;
       m_useCb_number = true;
       m_useCb_operator = true;
       m_useCb_package = true;
       m_useCb_parampin = true;
       m_useCb_pin = true;
       m_useCb_port = true;
       m_useCb_preproc = true;
       m_useCb_program = true;
       m_useCb_string = true;
       m_useCb_symbol = true;
       m_useCb_sysfunc = true;
       m_useCb_task = true;
       m_useCb_var = true;
   }
    // CALLBACKGEN_GENERATED_END - GENERATED AUTOMATICALLY by callbackgen
    // CALLBACKGEN_H_VIRTUAL
    // CALLBACKGEN_GENERATED_BEGIN - GENERATED AUTOMATICALLY by callbackgen
    // Verilog::Parser Callback methods
    virtual void attributeCb(VFileLine* fl, const string& text);
    virtual void commentCb(VFileLine* fl, const string& text);
    virtual void endparseCb(VFileLine* fl, const string& text);
    virtual void keywordCb(VFileLine* fl, const string& text);
    virtual void numberCb(VFileLine* fl, const string& text);
    virtual void operatorCb(VFileLine* fl, const string& text);
    virtual void preprocCb(VFileLine* fl, const string& text);
    virtual void stringCb(VFileLine* fl, const string& text);
    virtual void symbolCb(VFileLine* fl, const string& text);
    virtual void sysfuncCb(VFileLine* fl, const string& text);
    // Verilog::SigParser Callback methods
    virtual void classCb(VFileLine* fl, const string& kwd, const string& name, const string& virt);
    virtual void contassignCb(VFileLine* fl, const string& kwd, const string& lhs, const string& rhs);
    virtual void covergroupCb(VFileLine* fl, const string& kwd, const string& name);
    virtual void defparamCb(VFileLine* fl, const string& kwd, const string& lhs, const string& rhs);
    virtual void endcellCb(VFileLine* fl, const string& kwd);
    virtual void endclassCb(VFileLine* fl, const string& kwd);
    virtual void endgroupCb(VFileLine* fl, const string& kwd);
    virtual void endinterfaceCb(VFileLine* fl, const string& kwd);
    virtual void endmodportCb(VFileLine* fl, const string& kwd);
    virtual void endmoduleCb(VFileLine* fl, const string& kwd);
    virtual void endpackageCb(VFileLine* fl, const string& kwd);
    virtual void endprogramCb(VFileLine* fl, const string& kwd);
    virtual void endtaskfuncCb(VFileLine* fl, const string& kwd);
    virtual void functionCb(VFileLine* fl, const string& kwd, const string& name, const string& data_type);
    virtual void importCb(VFileLine* fl, const string& package, const string& id);
    virtual void instantCb(VFileLine* fl, const string& mod, const string& cell, const string& range);
    virtual void interfaceCb(VFileLine* fl, const string& kwd, const string& name);
    virtual void modportCb(VFileLine* fl, const string& kwd, const string& name);
    virtual void moduleCb(VFileLine* fl, const string& kwd, const string& name, bool, bool celldefine);
    virtual void packageCb(VFileLine* fl, const string& kwd, const string& name);
    virtual void parampinCb(VFileLine* fl, const string& name, const string& conn, int index);
    virtual void pinCb(VFileLine* fl, const string& name, const string& conn, int index);
    virtual void portCb(VFileLine* fl, const string& name, const string& objof, const string& direction, const string& data_type
	, const string& array, int index);
    virtual void programCb(VFileLine* fl, const string& kwd, const string& name);
    virtual void taskCb(VFileLine* fl, const string& kwd, const string& name);
    virtual void varCb(VFileLine* fl, const string& kwd, const string& name, const string& objof, const string& net
	, const string& data_type, const string& array, const string& value);
    // CALLBACKGEN_GENERATED_END - GENERATED AUTOMATICALLY by callbackgen

    void useCbEna(const char* name, bool flag);
    void call(string* rtnStrp, int params, const char* method, ...);
};

class VFileLineParseXs : public VFileLine {
    VParserXs*	m_vParserp;		// Parser handling the errors

public:
    VFileLineParseXs(VParserXs* pp) : VFileLine(true), m_vParserp(pp) { if (pp) pushFl(); }
    virtual ~VFileLineParseXs() { }
    virtual VFileLine* create(const string& filename, int lineno) {
	VFileLineParseXs* filelp = new VFileLineParseXs(m_vParserp);
	filelp->init(filename, lineno);
	return filelp;
    }
    virtual void error(const string& msg);	// Report a error at given location
    void setParser(VParserXs* pp) {
	m_vParserp=pp;
	pushFl(); // The very first construction used pp=NULL, as pp wasn't created yet so make it now
    }
    // Record the structure so we can delete it later
    void pushFl() { m_vParserp->m_filelineps.push_back(this); }
};

#//**********************************************************************
#// Overrides error handling virtual functions to invoke callbacks

void VFileLineParseXs::error(const string& msg) {
    static string holdmsg; holdmsg = msg;
    m_vParserp->cbFileline(this);
    // Call always, not just if callbacks enabled
    m_vParserp->call(NULL, 1,"error",holdmsg.c_str());
}

#//**********************************************************************
#// Overrides of virtual functions to invoke callbacks

#include "Parser_callbackgen.cpp"

#//**********************************************************************
#// VParserXs functions

VParserXs::~VParserXs() {
    for (deque<VFileLineParseXs*>::iterator it=m_filelineps.begin(); it!=m_filelineps.end(); ++it) {
	delete *it;
    }
}

#//**********************************************************************
#// General callback invoker

void VParserXs::call (
    string* rtnStrp,	/* If non-null, load return value here */
    int params,		/* Number of parameters */
    const char* method,	/* Name of method to call */
    ...)		/* Arguments to pass to method's @_ */
{
    // Call $perlself->method (passedparam1, parsedparam2)
    if (debug()) cout << "CALLBACK "<<method<<endl;
    va_list ap;
    va_start(ap, method);
    {
	dSP;				/* Initialize stack pointer */
	ENTER;				/* everything created after here */
	SAVETMPS;			/* ...is a temporary variable. */
	PUSHMARK(SP);			/* remember the stack pointer */
	SV* selfsv = newRV_inc(m_self);	/* $self-> */
	XPUSHs(sv_2mortal(selfsv));

	while (params--) {
	    char* text = va_arg(ap, char *);
	    SV* sv;
	    if (text) {
		sv = sv_2mortal(newSVpv (text, 0));
	    } else {
		sv = &PL_sv_undef;
	    }
	    XPUSHs(sv);			/* token */
	}

	PUTBACK;			/* make local stack pointer global */

	if (rtnStrp) {
	    int rtnCount = perl_call_method ((char*)method, G_SCALAR);
	    SPAGAIN;			/* refresh stack pointer */
	    if (rtnCount > 0) {
		SV* sv = POPs;
		//printf("RTN %ld %d %s\n", SvTYPE(sv),SvTRUE(sv),SvPV_nolen(sv));
#ifdef SvPV_nolen	// Perl 5.6 and later
		*rtnStrp = SvPV_nolen(sv);
#else
		*rtnStrp = SvPV(sv,PL_na);
#endif
	    }
	    PUTBACK;
	} else {
	    perl_call_method ((char*)method, G_DISCARD | G_VOID);
	}

	FREETMPS;			/* free that return value */
	LEAVE;				/* ...and the XPUSHed "mortal" args.*/
    }
    va_end(ap);
}

#//**********************************************************************

#line 311 "Parser.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 453 "Parser.c"

XS_EUPXS(XS_Verilog__Parser__new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Verilog__Parser__new)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "CLASS, SELF, symsp, sigparser, useUnreadback");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	VParserXs *	RETVAL;
	SV*	SELF = ST(1)
;
	AV*	symsp;
	bool	sigparser = (bool)SvTRUE(ST(3))
;
	bool	useUnreadback = (bool)SvTRUE(ST(4))
;

	STMT_START {
		SV* const xsub_tmp_sv = ST(2);
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVAV){
		    symsp = (AV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ "%s: %s is not an ARRAY reference",
				"Verilog::Parser::_new",
				"symsp");
		}
	} STMT_END
;
#line 310 "Parser.xs"
{
    if (CLASS) {}  /* Prevent unused warning */
    if (!SvROK(SELF)) { warn("${Package}::$func_name() -- SELF is not a hash reference"); }
    VFileLineParseXs* filelinep = new VFileLineParseXs(NULL/*ok,for initial*/);
    VParserXs* parserp = new VParserXs(filelinep, symsp, sigparser, useUnreadback);
    filelinep->setParser(parserp);
    parserp->m_self = SvRV(SELF);
    RETVAL = parserp;
}
#line 496 "Parser.c"
	ST(0) = sv_newmortal();
    // SELF->{_cthis} = THIS
    if( sv_isobject(SELF) && (SvTYPE(SvRV(SELF)) == SVt_PVHV) ) {
	SV **svp = hv_fetch ((HV*)SvRV(SELF), "_cthis", 6, 1);
	sv_setiv(*svp, PTR2IV( RETVAL ));
	XSRETURN_UNDEF;
    } else {
        warn( "Verilog::Parser::_new() -- RETVAL is not a Verilog::Parser object" );
        XSRETURN_UNDEF;
    }
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Verilog__Parser__DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Verilog__Parser__DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	VParserXs *    THIS = NULL;
    if( sv_isobject(ST(0)) && (SvTYPE(SvRV( ST(0) )) == SVt_PVHV) ) {
        SV **svp = hv_fetch ((HV*)SvRV(( ST(0) )), "_cthis", 6, 0);
	THIS = NULL;
	if (svp) { THIS = INT2PTR(VParserXs *,SvIV( *svp )); }
    }
    if (!THIS || !dynamic_cast<VParserXs*>(THIS)) {
        warn( "Verilog::Parser::_DESTROY() -- THIS is not a Verilog::Parser object" );
        XSRETURN_UNDEF;
    }
;
#line 328 "Parser.xs"
{
    delete THIS;
}
#line 534 "Parser.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Verilog__Parser__debug); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Verilog__Parser__debug)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, level");
    {
	int	level = (int)SvIV(ST(1))
;
	VParserXs *    THIS = NULL;
    if( sv_isobject(ST(0)) && (SvTYPE(SvRV( ST(0) )) == SVt_PVHV) ) {
        SV **svp = hv_fetch ((HV*)SvRV(( ST(0) )), "_cthis", 6, 0);
	THIS = NULL;
	if (svp) { THIS = INT2PTR(VParserXs *,SvIV( *svp )); }
    }
    if (!THIS || !dynamic_cast<VParserXs*>(THIS)) {
        warn( "Verilog::Parser::_debug() -- THIS is not a Verilog::Parser object" );
        XSRETURN_UNDEF;
    }
;
#line 340 "Parser.xs"
{
    THIS->debug(level);
    VAstEnt::debug(level);
}
#line 565 "Parser.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Verilog__Parser__callback_master_enable); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Verilog__Parser__callback_master_enable)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, flag");
    {
	bool	flag = (bool)SvTRUE(ST(1))
;
	VParserXs *    THIS = NULL;
    if( sv_isobject(ST(0)) && (SvTYPE(SvRV( ST(0) )) == SVt_PVHV) ) {
        SV **svp = hv_fetch ((HV*)SvRV(( ST(0) )), "_cthis", 6, 0);
	THIS = NULL;
	if (svp) { THIS = INT2PTR(VParserXs *,SvIV( *svp )); }
    }
    if (!THIS || !dynamic_cast<VParserXs*>(THIS)) {
        warn( "Verilog::Parser::_callback_master_enable() -- THIS is not a Verilog::Parser object" );
        XSRETURN_UNDEF;
    }
;
#line 354 "Parser.xs"
{
    THIS->callbackMasterEna(flag);
}
#line 595 "Parser.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Verilog__Parser__use_cb); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Verilog__Parser__use_cb)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, name, flag");
    {
	VParserXs *    THIS = NULL;
    if( sv_isobject(ST(0)) && (SvTYPE(SvRV( ST(0) )) == SVt_PVHV) ) {
        SV **svp = hv_fetch ((HV*)SvRV(( ST(0) )), "_cthis", 6, 0);
	THIS = NULL;
	if (svp) { THIS = INT2PTR(VParserXs *,SvIV( *svp )); }
    }
    if (!THIS || !dynamic_cast<VParserXs*>(THIS)) {
        warn( "Verilog::Parser::_use_cb() -- THIS is not a Verilog::Parser object" );
        XSRETURN_UNDEF;
    }
;
	const char*	name = (const char *)SvPV_nolen(ST(1))
;
	bool	flag = (bool)SvTRUE(ST(2))
;
#line 366 "Parser.xs"
{
    THIS->useCbEna(name,flag);
}
#line 627 "Parser.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Verilog__Parser_eof); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Verilog__Parser_eof)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	VParserXs *    THIS = NULL;
    if( sv_isobject(ST(0)) && (SvTYPE(SvRV( ST(0) )) == SVt_PVHV) ) {
        SV **svp = hv_fetch ((HV*)SvRV(( ST(0) )), "_cthis", 6, 0);
	THIS = NULL;
	if (svp) { THIS = INT2PTR(VParserXs *,SvIV( *svp )); }
    }
    if (!THIS || !dynamic_cast<VParserXs*>(THIS)) {
        warn( "Verilog::Parser::eof() -- THIS is not a Verilog::Parser object" );
        XSRETURN_UNDEF;
    }
;
#line 377 "Parser.xs"
{
    THIS->setEof();
}
#line 655 "Parser.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Verilog__Parser_filename); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Verilog__Parser_filename)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "THIS, flagp=\"\"");
    {
	VParserXs *    THIS = NULL;
    if( sv_isobject(ST(0)) && (SvTYPE(SvRV( ST(0) )) == SVt_PVHV) ) {
        SV **svp = hv_fetch ((HV*)SvRV(( ST(0) )), "_cthis", 6, 0);
	THIS = NULL;
	if (svp) { THIS = INT2PTR(VParserXs *,SvIV( *svp )); }
    }
    if (!THIS || !dynamic_cast<VParserXs*>(THIS)) {
        warn( "Verilog::Parser::filename() -- THIS is not a Verilog::Parser object" );
        XSRETURN_UNDEF;
    }
;
	SV *	RETVAL;
	const char*	flagp;

	if (items < 2)
	    flagp = "";
	else {
	    flagp = (const char *)SvPV_nolen(ST(1))
;
	}
#line 387 "Parser.xs"
{
    if (!THIS) XSRETURN_UNDEF;
    if (items > 1) {
	THIS->inFileline(flagp, THIS->inFilelinep()->lineno());
	THIS->cbFileline(THIS->inFilelinep());
    }
    string ret = THIS->cbFilelinep()->filename();
    RETVAL = newSVpv(ret.c_str(), ret.length());
}
#line 698 "Parser.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Verilog__Parser_language); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Verilog__Parser_language)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, valuep");
    {
	const char*	valuep = (const char *)SvPV_nolen(ST(1))
;
	VParserXs *    THIS = NULL;
    if( sv_isobject(ST(0)) && (SvTYPE(SvRV( ST(0) )) == SVt_PVHV) ) {
        SV **svp = hv_fetch ((HV*)SvRV(( ST(0) )), "_cthis", 6, 0);
	THIS = NULL;
	if (svp) { THIS = INT2PTR(VParserXs *,SvIV( *svp )); }
    }
    if (!THIS || !dynamic_cast<VParserXs*>(THIS)) {
        warn( "Verilog::Parser::language() -- THIS is not a Verilog::Parser object" );
        XSRETURN_UNDEF;
    }
;
#line 406 "Parser.xs"
{
    if (items > 1) {
        THIS->language(valuep);
    }
}
#line 732 "Parser.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Verilog__Parser_lineno); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Verilog__Parser_lineno)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "THIS, flag=0");
    {
	VParserXs *    THIS = NULL;
    if( sv_isobject(ST(0)) && (SvTYPE(SvRV( ST(0) )) == SVt_PVHV) ) {
        SV **svp = hv_fetch ((HV*)SvRV(( ST(0) )), "_cthis", 6, 0);
	THIS = NULL;
	if (svp) { THIS = INT2PTR(VParserXs *,SvIV( *svp )); }
    }
    if (!THIS || !dynamic_cast<VParserXs*>(THIS)) {
        warn( "Verilog::Parser::lineno() -- THIS is not a Verilog::Parser object" );
        XSRETURN_UNDEF;
    }
;
	int	RETVAL;
	dXSTARG;
	int	flag;

	if (items < 2)
	    flag = 0;
	else {
	    flag = (int)SvIV(ST(1))
;
	}
#line 419 "Parser.xs"
{
    if (!THIS) XSRETURN_UNDEF;
    if (items > 1) {
	THIS->inFileline(THIS->inFilelinep()->filename(), flag);
	THIS->cbFileline(THIS->inFilelinep());
    }
    RETVAL = (THIS->cbFilelinep()->lineno());
}
#line 775 "Parser.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Verilog__Parser_parse); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Verilog__Parser_parse)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, textp");
    {
	VParserXs *    THIS = NULL;
    if( sv_isobject(ST(0)) && (SvTYPE(SvRV( ST(0) )) == SVt_PVHV) ) {
        SV **svp = hv_fetch ((HV*)SvRV(( ST(0) )), "_cthis", 6, 0);
	THIS = NULL;
	if (svp) { THIS = INT2PTR(VParserXs *,SvIV( *svp )); }
    }
    if (!THIS || !dynamic_cast<VParserXs*>(THIS)) {
        warn( "Verilog::Parser::parse() -- THIS is not a Verilog::Parser object" );
        XSRETURN_UNDEF;
    }
;
	const char*	textp = (const char *)SvPV_nolen(ST(1))
;
#line 436 "Parser.xs"
{
    THIS->parse(textp);
}
#line 806 "Parser.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Verilog__Parser_selftest); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Verilog__Parser_selftest)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	VParserXs *    THIS = NULL;
    if( sv_isobject(ST(0)) && (SvTYPE(SvRV( ST(0) )) == SVt_PVHV) ) {
        SV **svp = hv_fetch ((HV*)SvRV(( ST(0) )), "_cthis", 6, 0);
	THIS = NULL;
	if (svp) { THIS = INT2PTR(VParserXs *,SvIV( *svp )); }
    }
    if (!THIS || !dynamic_cast<VParserXs*>(THIS)) {
        warn( "Verilog::Parser::selftest() -- THIS is not a Verilog::Parser object" );
        XSRETURN_UNDEF;
    }
;
#line 447 "Parser.xs"
{
    VSymStack::selftest();
    assert(VParse::isKeyword("wire",strlen("wire")));
    assert(!VParse::isKeyword("wire99",strlen("wide99")));
}
#line 836 "Parser.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Verilog__Parser_unreadback); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Verilog__Parser_unreadback)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "THIS, flagp=\"\"");
    {
	VParserXs *    THIS = NULL;
    if( sv_isobject(ST(0)) && (SvTYPE(SvRV( ST(0) )) == SVt_PVHV) ) {
        SV **svp = hv_fetch ((HV*)SvRV(( ST(0) )), "_cthis", 6, 0);
	THIS = NULL;
	if (svp) { THIS = INT2PTR(VParserXs *,SvIV( *svp )); }
    }
    if (!THIS || !dynamic_cast<VParserXs*>(THIS)) {
        warn( "Verilog::Parser::unreadback() -- THIS is not a Verilog::Parser object" );
        XSRETURN_UNDEF;
    }
;
	SV *	RETVAL;
	const char*	flagp;

	if (items < 2)
	    flagp = "";
	else {
	    flagp = (const char *)SvPV_nolen(ST(1))
;
	}
#line 460 "Parser.xs"
{
    if (!THIS) XSRETURN_UNDEF;
    // Set RETVAL to a SV before we replace with the new value, and c_str may change
    string ret = THIS->unreadback();
    RETVAL = newSVpv(ret.c_str(), ret.length());
    if (items > 1) {
	THIS->unreadback(flagp);
    }
}
#line 879 "Parser.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Verilog__Parser_unreadbackCat); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Verilog__Parser_unreadbackCat)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, textsvp");
    {
	VParserXs *    THIS = NULL;
    if( sv_isobject(ST(0)) && (SvTYPE(SvRV( ST(0) )) == SVt_PVHV) ) {
        SV **svp = hv_fetch ((HV*)SvRV(( ST(0) )), "_cthis", 6, 0);
	THIS = NULL;
	if (svp) { THIS = INT2PTR(VParserXs *,SvIV( *svp )); }
    }
    if (!THIS || !dynamic_cast<VParserXs*>(THIS)) {
        warn( "Verilog::Parser::unreadbackCat() -- THIS is not a Verilog::Parser object" );
        XSRETURN_UNDEF;
    }
;
	SV*	textsvp = ST(1)
;
#line 478 "Parser.xs"
{
    if (!THIS) XSRETURN_UNDEF;
    STRLEN textlen;
    const char* textp = SvPV(textsvp, textlen);
    THIS->unreadbackCat(textp, textlen);
}
#line 914 "Parser.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Verilog__Parser); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Verilog__Parser)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        (void)newXSproto_portable("Verilog::Parser::_new", XS_Verilog__Parser__new, file, "$$$$");
        (void)newXSproto_portable("Verilog::Parser::_DESTROY", XS_Verilog__Parser__DESTROY, file, "$");
        (void)newXSproto_portable("Verilog::Parser::_debug", XS_Verilog__Parser__debug, file, "$$");
        (void)newXSproto_portable("Verilog::Parser::_callback_master_enable", XS_Verilog__Parser__callback_master_enable, file, "$$");
        (void)newXSproto_portable("Verilog::Parser::_use_cb", XS_Verilog__Parser__use_cb, file, "$$$");
        (void)newXSproto_portable("Verilog::Parser::eof", XS_Verilog__Parser_eof, file, "$");
        (void)newXSproto_portable("Verilog::Parser::filename", XS_Verilog__Parser_filename, file, "$;$");
        (void)newXSproto_portable("Verilog::Parser::language", XS_Verilog__Parser_language, file, "$$");
        (void)newXSproto_portable("Verilog::Parser::lineno", XS_Verilog__Parser_lineno, file, "$;$");
        (void)newXSproto_portable("Verilog::Parser::parse", XS_Verilog__Parser_parse, file, "$$");
        (void)newXSproto_portable("Verilog::Parser::selftest", XS_Verilog__Parser_selftest, file, "$");
        (void)newXSproto_portable("Verilog::Parser::unreadback", XS_Verilog__Parser_unreadback, file, "$;$");
        (void)newXSproto_portable("Verilog::Parser::unreadbackCat", XS_Verilog__Parser_unreadbackCat, file, "$$");
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

